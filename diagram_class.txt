PACKAGES:

CONTROLLER {

MainController:
- model : BddManager
- view : InterfaceManager
- com : SocketManager

+ initialize() // Vérifie si bdd existe, si non -> création de la bdd
+ displayLoginWindow()
+ getLocalUser() : User
+ choosePseudo() // input user => update la bdd (addUser()) puis broadcast
+ notifyUserConnection() // broadcast de id/pseudo et attend les réponses des online users pour les insérer dans la bdd
+ notifyUserDisconnection() // broadcast de id/pseudo
+ displayChatWindow()

+ startSession(User target) // Crée une communication (socket) avec target
+ leaveSession(User target) // Ferme la communication avec target
+ activeSessionGUI(User target) // Vérifie l'existence d'un panel avec target. Si oui -> setVisible, si non -> le crée puis setVisible

+ sendMessage(byte[] data, User target) // only user messages
+ processMessage(Message msg) // send the message to the bddmanager to decode it
+ getLog(User target)


SocketManager:
- list_session : HashMap <User,ClientConnection>
- frontdoor : waitingConnection
- broadcast_socket : UDPSocket

+ initiateClientConnection(User target)
+ acceptRemoteConnection(Socket socket)
+ listenConnection() : Socket
+ listenMessage() : byte[] data
+ sendUserMessage(byte[] data, User target)
+ sendSystemMessage(type_sys ts, User source) // appelle broadcast UDP


public enum type_sys {Hello, Goodbye, ChangePseudo}

ClientConnection extends Thread:
- dest : User
- socket : Socket

+ sendMessage(byte[] data) // adds US in front of the message, to know it's a user message 
+ readLine()
+ println(byte[] data) //sends data to the destination user


waitingConnection extends Thread:
- serv_socket : ServerSocket

+ listen() : Socket
+ createClientConnection(Socket socket)


UDPSocket:
- socket : DatagramSocket

+ broadcast(User source, bool state) // state = connected or not
+ listen() // wait for other users broadcasts

}

VIEW {

InterfaceManager:
- login : LoginWindow
- chat_window : ChatWindow

+ setActiveChatFrame(User target) // désactive toutes les chatframe et active celle avec target
+ changeActiveChatPanel(User target)
+ displayChatWindow()
+ displayLoginWindow()

LoginWindow:
- login_frame : JFrame
- change_pseudo : JButton
- enter_pseudo : JTextField

ChatWindow:
- chat_frame : JFrame
- user_list : UserPanel
- chat_panel : <User,ChatPanel>HashMap
- active_chat_panel : ChatPanel
- msg_to_send : JTextField
- send_button : JButton
- pseudo_panel : JPanel
- current_pseudo : JLabel
- change_pseudo : JButton

+ display() // appelle pack(), appelle setVisible() et recrée une 
+ changeActiveChatPanel(User target) // 

UserPanel:
- connected_users : User list

+ displayUserList() // Crée un JButton pour chaque connected user 

ChatPanel:
- dest: User
- isActive: bool
- message_history : Log

}

MODEL {

BddManager:
- logs: Log list
- connectedUsers: User list
- localUser: User

+ decode(Message msg) // takes a msg, finds whether it is an user msg or a system message and forwards it to the right method 
+ addMsg(Message msg) // notify
+ getMsgHistory(User target) // if Log with target doesn't exit => instanciate a Log with the user, read the bdd to get all messages involving this user, create a Message for each, add this Message to Log and then add this Log to logs | else parcourir logs jusqu'à Log.getTarget() = target then getHistory()
+ addUser(id, pseudo) // notify. If User doesnt exist, creates it. Else, updates its pseudo.
+ rmUser(id) // notify
+ getConnectedUsers()
+ setLocalUser(id, pseudo)
+ getLocalUser()

Log:
- target: User
- history: Message list

- setTarget(User user)
- getTarget()
- addMsg(string source, string dest, byte[] data)
- getHistory()


Message:
- source : string // id de la source
- dest : string // id du destinataire
- data : byte[]
- timestamp : Date

+ getSource()
+ setSource(string source)
+ getDest()
+ setDest(string dest)
+ getData()
+ setData(byte[] data)
+ getTimestamp()
+ setTimestamp(Date timestamp)


User:
- id: string // adresse IP ou hash
- pseudo: string

+ getId()
+ setId(string id)
+ getPseudo()
+ setPseudo(string pseudo)

}
